# Лабораторная работа № 3 # 

**Студент:** Выдумкин Илья Александрович 
**группа:** P 4150  
**дисциплина:** "Взаимодействие с базами данных"
**Дата:** 27.03.2025  
** Задание:
Лабораторная
Лабораторная работа 3.
Для выполнения лабораторной работы №3 необходимо:
1.  Реализованную в рамках лабораторной работы №2 даталогическую модель привести в 3 нормальную форму. Если в вашей предметной области эффективнее использовать денормализованную модель – это нужно обосновать при сдаче ЛР. 
2.  Привести 3 примера анализа функциональной зависимости атрибутов. Соответственно, для трех таблиц (в предметной области каждого студента должно быть не менее трех таблиц). 
3.  Обеспечить целостность данных таблиц при помощи средств языка DDL. Задача – это продемонстрировать знание видов ограничений целостности. Чем больше будет использовано, тем меньше вопросов будет задано. 
4.  Заполнить таблицы данными
5.  В рамках лабораторной работы должны быть разработаны скрипты-примеры для создания/удаления требуемых объектов базы данных, заполнения/удаления содержимого созданных таблиц. Студент должен быть готов продемонстрировать работу скриптов!
6.  Составить 6+3 примеров SQL запросов на объединение таблиц предметной области. Студент должен быть готов продемонстрировать работу запросов и обосновать их результаты, почему они получились именно такими. 6 – это INNER, FULL, LEFT, RIGTH, CROSS, OUTER и еще 3 JOIN ON, JOIN USING, NATURAL JOIN

Отчёт по лабораторной работе должен содержать:
·  Имя студента
·  Группа
·  Дата выполнения задания
·  Именование дисциплины
·  Текст задания;
·  Описание предметной области;
·  Последняя реализованная Даталогическая модель
·  Результат выполнения пункта 2 ЛР, то есть описание анализа функциональной зависимости. Помним, что Функциональная зависимость атрибутов отражается стрелкой А → B
·  Составленные SQL-запросы: пример заполнения данных каждой таблицы (достаточно по одному примеру), SQL-запросы из пунктов 5, 6

Темы для подготовки к защите лабораторной работы:
1.  Что такое функицональная зависимость атрибутов? Почему это понятие важно? Какие существуют виды функц. Зависимостей
2.  Аномалии. Виды аномалий 
3.  Виды нормальных форм. В чем их цель, почему важны, чем отличаются друг от друга
4.  Денормализация. Когда можно пренебречь нормализацией, в пользу чего. Как определить потребность в денормализации
5.  Работа операторов соединения таблиц, виды JOIN-запросов. Их соответствие операторам алгебры логики.
6.  Какие существуют операторы логические, сравнения, поиска по шаблону. Как они работают? Что такое предикат сравнения?
7.  Подзапросы IN, EXISTS, ANY, SOME
8.  Соединение таблиц при помощи WHERE

Описание защиты: ответ на 3 теор. Вопроса, выполнение практического задания.
# Описание предметной области #
Система мониторинга и расчета показателей микроклимата состоит из датчиков 2х типов( температуры и влажности) и внешних источников погоды. Каждый датчик принадлежит определенному помещени и характеризуется id. Помещения характеризуются: площадью, высотой потолков, площадью остекления и внешних стен. Пользователи обладают набором помещений, расположенном в определенном географическом месте, характеризуемом координатами широты и долготы. Модули расчета производят регулярный мониторинг микроклимата, собирая данные с датчиков и запрашивая данные о погоде из внешних источников. Мониторинг осуществляется каждые 4 часа. Каждая ссессия сбора информации о микроклимате, собирается в таблицу наблюдений по конкретному пользователю.  Каждый пользователь характеризуется именем, фамилией, логином в системе и паролем.

# Инфологическая модель #

@startuml
entity "Помещение" {
  + ID помещения : INTEGER <<PK>>
  + тип помещения : VARCHAR
  + площадь помещения : FLOAT
  + высота потолков : FLOAT
  + площадь остекления : FLOAT
  + площадь внешних стен : FLOAT
  + id датчика температуры : INTEGER <<FK>>
  + id датчика влажности : INTEGER <<FK>>
  + логин пользователя (INTEGER <<FK>>
}  
entity "Пользователь"{ 
  + Фамилия : VARCHAR
  + Имя : VARCHAR
  + Контактная информация : VARCHAR
  + Дата регистрации : DATE
  + логин пользователя : VARCHAR <<PK>>
  + Пароль в системе : VARCHAR
}
entity "Квартира" {
  + id квартиры : INTEGER <<PK>>
  + номер квартиры: INTEGER 
  + логин пользователя : VARCHAR <<FK>>
  + id помещения: INTEGER <<FK>>
  + географическая широта : FLOAT
  + географическая долгота : FLOAT
}

entity "Датчики" {
  + ID датчика : INTEGER <<PK>>
  + тип датчика : VARCHAR
  + Дата установки : DATE
}

entity "Наблюдения" {
  + id наблюдения : INTEGER <<PK>>
  + id помещения : INTEGER <<FK>>
  + время наблюдения : DATETIME
  + id  датчика температуры: INTEGER <<FK>>
  + показания датчика температуры : FLOAT
  + id датчика влажности: INTEGER <<FK>>
  + показания датчика влажности : FLOAT
  + температура за окном : FLOAT
}

Помещение "1" -- "2" Датчики : "имеет"
Пользователь "1" -- "0..*" Квартира : "владеет"
Помещение "1" -- "0..*" Наблюдения : "содержит"
Датчики "0..*" -- "0..*" Наблюдения : "предоставляет"
@enduml

# Описание функциональных связей. #
Опираясь на даталогическую модель, мы можем выделить функциональные зависимости между атрибутами, основанные на отношениях между сущностями. В функциональных зависимостях мы рассматриваем, как значения одного или нескольких атрибутов определяют значение другого атрибута.
### Сущность "Пользователь"
- логин пользователя → {Фамилия, Имя, Контактная информация, Дата регистрации, Пароль в системе}
  - Логин пользователя определяет все остальные атрибуты, так как он уникален для каждого пользователя.
### Сущность "Помещение"
- ID помещения → {тип помещения, площадь помещения, высота потолков, площадь остекления, площадь внешних стен, id датчика температуры, id датчика влажности, логин пользователя}
  - ID помещения определяет все его характеристики. Все остальные атрибуты зависят от уникального идентификатора помещения.
### Сущность "Квартира"
- id квартиры → {номер квартиры, логин пользователя, id помещения, географическая широта, географическая долгота}
  - ID квартиры определяет все другие атрибуты. Номер квартиры уникален для каждого пользователя, поэтому его можно использовать для определения соответствующего логина пользователя и информации о помещении.
### Сущность "Датчики"
- ID датчика → {тип датчика, Дата установки}
  - ID датчика определяет тип датчика и дату его установки. Каждый датчик уникален, благодаря чему его ID может однозначно определить остальные атрибуты.
### Сущность "Наблюдения"
- id наблюдения → {id помещения, время наблюдения, id датчика температуры, показания датчика температуры, id датчика влажности, показания датчика влажности, температура за окном}
  - ID наблюдения уникален и определяет связанные с ним атрибуты. Уникальный идентификатор наблюдения позволяет получить всю информацию о конкретном наблюдении.
Мы можем говорить также о зависимости:
- id помещения, время наблюдения → {id датчика температуры, показания датчика температуры, id датчика влажности, показания датчика влажности, температура за окном}
  - Эта зависимость может выражать, что у конкретного помещения в заданный момент времени могут быть только определенные показания температурных и влажностных датчиков. Но в силу свойств транзитивности, она сводится к зависимости от id наблюдения.

# SQL- запросы по заполнению баз данных #

INSERT INTO USERS (login, last_name, first_name, contact_info, registration_date, password) VALUES ('user1', 'Smith', 'John', 'john.smith@example.com', '2023-01-01', 'password1'), ('user2', 'Doe', 'Jane', 'jane.doe@example.com', '2023-01-02', 'password2'), ('user3', 'Johnson', 'Emily', 'emily.johnson@example.com', '2023-01-03', 'password3');

INSERT INTO Sensors (sensor_type, installation_date) VALUES ('temp', '2023-01-01'), ('Hum', '2023-01-02'), ('temp', '2023-01-03');

INSERT INTO Room (room_type, room_area, ceiling_height, glazing_area, external_wall_area, temperature_sensor_id, humidity_sensor_id, login) VALUES ('Kitchen', 20.5, 2.5, 5.0, 15.0, 1, 2, 'user1'), ('Living_Room', 25.0, 2.8, 10.0, 20.0, 2, 3, 'user2'), ('Bath_Room', 10.0, 2.4, 2.0, 7.0, NULL, 3, 'user3');
INSERT INTO Flat (flat_number, login, room_id, latitude, longitude) VALUES (101, 'user1', 1, 40.7128, -74.0060), (102, 'user2', 2, 34.0522, -118.2437), (103, 'user3', 3, 51.5074, -0.1278);
INSERT INTO Observations (room_id, observation_time, temperature_sensor_id, temperature_reading, humidity_sensor_id, humidity_reading, outside_temperature) VALUES (1, '2023-01-10 10:00:00', 1, 22.5, 2, 55.0, 5.0), (2, '2023-01-11 11:00:00', 2, 21.0, 3, 60.0, 6.0), (3, '2023-01-12 12:00:00', 1, 23.0, 2, 58.0, 4.5);

# JOIN запросы #
1. INNER JOIN
SELECT u.login, r.room_type, s.sensor_type
FROM USERS u
INNER JOIN Room r ON u.login = r.login
INNER JOIN Sensors s ON r.temperature_sensor_id = s.sensor_id OR r.humidity_sensor_id = s.sensor_id;
 Возвращает логины пользователей, типы комнат и типы датчиков, где у них есть совпадения.
login |  room_type  | sensor_type
-------+-------------+-------------
 user1 | Kitchen     | temp
 user1 | Kitchen     | Hum
 user2 | Living_Room | Hum
 user2 | Living_Room | temp
 user3 | Bath_Room   | temp
(5 ёЄЁюъ)

2. LEFT JOIN
SELECT u.login, r.room_type, s.sensor_type
FROM USERS u
LEFT JOIN Room r ON u.login = r.login
LEFT JOIN Sensors s ON r.temperature_sensor_id = s.sensor_id OR r.humidity_sensor_id = s.sensor_id;
 Возвращает всех пользователей и их комнаты с типами датчиков.
login |  room_type  | sensor_type
-------+-------------+-------------
 user1 | Kitchen     | temp
 user1 | Kitchen     | Hum
 user2 | Living_Room | Hum
 user2 | Living_Room | temp
 user3 | Bath_Room   | temp
(5 ёЄЁюъ)
3. RIGHT JOIN
SELECT s.sensor_type, r.room_type
FROM Sensors s
RIGHT JOIN Room r ON s.sensor_id = r.temperature_sensor_id OR s.sensor_id = r.humidity_sensor_id;
Получаем все сенсорыпо типу  и соответствующие типы помещений,
sensor_type |  room_type
-------------+-------------
 temp        | Kitchen
 Hum         | Kitchen
 Hum         | Living_Room
 temp        | Living_Room
 temp        | Bath_Room
(5 ёЄЁюъ)
4. FULL OUTER JOIN
SELECT u.login, r.room_type
FROM USERS u
FULL OUTER JOIN Room r ON u.login = r.login;
Возвращает типы помещений по логинам пользователей.
 login |  room_type
-------+-------------
 user1 | Kitchen
 user2 | Living_Room
 user3 | Bath_Room
(3 ёЄЁюъш)
5. CROSS JOIN
SELECT u.login, r.room_type
FROM USERS u
CROSS JOIN Room r;
 Возвращает каждую возможную комбинацию пользователей и комнат (декартово произведение).
login |  room_type
-------+-------------
 user1 | Kitchen
 user2 | Kitchen
 user3 | Kitchen
 user1 | Living_Room
 user2 | Living_Room
 user3 | Living_Room
 user1 | Bath_Room
 user2 | Bath_Room
 user3 | Bath_Room
(9 ёЄЁюъ)
6. JOIN ON
SELECT u.first_name, r.room_type, o.observation_time, o.temperature_reading
FROM USERS u
JOIN Room r ON u.login = r.login
JOIN Observations o ON r.room_id = o.room_id;
Возвращает имена пользователей, типы комнат и данные наблюдений по температуре.
first_name |  room_type  |  observation_time   | temperature_reading
------------+-------------+---------------------+---------------------
 John       | Kitchen     | 2023-01-10 10:00:00 |                22.5
 Jane       | Living_Room | 2023-01-11 11:00:00 |                  21
 Emily      | Bath_Room   | 2023-01-12 12:00:00 |                  23
(3 ёЄЁюъш)

7. JOIN USING
SELECT u.first_name, f.flat_number
FROM USERS u
JOIN Flat f USING (login);
 Возвращает имена пользователей и номера квартир, используя общий столбец login.
first_name | flat_number
------------+-------------
 John       |         101
 Jane       |         102
 Emily      |         103
(3 ёЄЁюъш)
8. NATURAL JOIN
SELECT r.room_id, s.sensor_type
FROM Room r
NATURAL JOIN Sensors s;
Автоматически соединяет таблицы Room и Sensors по столбцу sensor_id, если он присутствует в обеих таблицах.
room_id | sensor_type
---------+-------------
       1 | temp
       2 | temp
       3 | temp
       1 | Hum
       2 | Hum
       3 | Hum
       1 | temp
       2 | temp
       3 | temp
(9 ёЄЁюъ)
9. INNER JOIN с условиями фильтрации
SELECT u.last_name, o.temperature_reading
FROM USERS u
INNER JOIN Observations o ON u.login = (SELECT login FROM Flat WHERE room_id = o.room_id)
WHERE o.observation_time > '2023-01-10';
 Возвращает фамилии пользователей и показания температур за указанный период времени.
last_name | temperature_reading
-----------+---------------------
 Smith     |                22.5
 Doe       |                  21
 Johnson   |                  23
(3 
10. LEFT JOIN с условием на количество
SELECT u.login, COUNT(f.flat_id) AS flats_count
FROM USERS u
LEFT JOIN Flat f ON u.login = f.login
GROUP BY u.login;
Возвращает таблицу количества квартир, сгруппированных по login. 
login | flats_count
-------+-------------
 user3 |           1
 user2 |           1
 user1 |           1
(3 ёЄЁюъш)
# Скрипты по удалению строк и таблиц #
1. Удалим наблюдения по конкретному пользователю, начиная с определенной даты:
DELETE FROM Observations
WHERE room_id IN (
    SELECT room_id FROM Room
    WHERE login = 'user1'
)
AND observation_time >= '2023-01-01';
2. Очистим таблицу квартир:
DELETE FROM Flat;
# Выводы #
В ходе выполнения задания на основе описания предметной области и построенной и заполненной пробными данными  Базы данных были изучены функциональные зависимости,и опробованы различные виды использования оператора JOIN. Опробованы различные команды по добавлению, удалению и изменению данных. 